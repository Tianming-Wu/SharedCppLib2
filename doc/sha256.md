# sha256 - SHA256 Hash Library

+ Name: sha256  
+ Namespace: `sha256`  
+ Document Version: `1.0.0`

## CMake Info

| Item | Value |
|---------|---------|
| Namespace | `SharedCppLib2` |
| Library | `sha256` |

To include:
```cmake
find_package(SharedCppLib2 REQUIRED)
target_link_libraries(target SharedCppLib2::sha256)
```

## Description

SHA256 library provides implementation of the SHA-256 cryptographic hash function (FIPS 180-4). It produces a 256-bit (32-byte) hash value, typically rendered as a 64-digit hexadecimal number. This library is suitable for data integrity verification, digital signatures, and cryptographic applications.

## Quick Start

### Basic File Hashing
```cpp
#include <SharedCppLib2/sha256.hpp>
#include <SharedCppLib2/bytearray.hpp>
#include <fstream>

int main() {
    std::ifstream ifs("file.txt", std::ios::binary);
    std::bytearray file_data;
    file_data.readAllFromStream(ifs);
    
    std::bytearray hash = sha256::getMessageDigest(file_data);
    std::cout << "SHA256: " << hash.tohex() << std::endl;
    
    return 0;
}
```

### String Hashing
```cpp
#include <SharedCppLib2/sha256.hpp>

std::string text = "Hello World";
std::string hex_hash = sha256::getHexMessageDigest(text);
std::cout << "Hash: " << hex_hash << std::endl;
```

## Core Functions

### encrypt
```cpp
bool encrypt(const std::bytearray& message, std::bytearray* _digest);
```
Computes SHA256 hash of input message.

**Parameters:**
- `message`: Input data to hash
- `_digest`: Output parameter for the resulting hash (32 bytes)

**Returns:** `true` if successful, `false` on error

**Example:**
```cpp
std::bytearray data = "Hello World";
std::bytearray hash;
if (sha256::encrypt(data, &hash)) {
    std::cout << "Hash: " << hash.tohex() << std::endl;
}
```

### getHexMessageDigest
```cpp
std::string getHexMessageDigest(const std::string& message);
```
Computes SHA256 hash of a string and returns hexadecimal representation.

**Parameters:**
- `message`: Input string to hash

**Returns:** 64-character hexadecimal hash string

**Example:**
```cpp
std::string hash = sha256::getHexMessageDigest("password123");
// Returns: "ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f"
```

### getMessageDigest
```cpp
std::bytearray getMessageDigest(std::bytearray message);
```
Computes SHA256 hash of bytearray data.

**Parameters:**
- `message`: Input bytearray to hash

**Returns:** Bytearray containing the 32-byte hash

**Example:**
```cpp
std::bytearray data = {std::byte{0x48}, std::byte{0x65}, std::byte{0x6c}, std::byte{0x6c}, std::byte{0x6f}};
std::bytearray hash = sha256::getMessageDigest(data);
std::cout << hash.tohex() << std::endl;
```

## Algorithm Details

The SHA256 implementation follows the standard specification:

1. **Preprocessing**: Padding and length appending
2. **Chunk Processing**: Breaking into 512-bit (64-byte) blocks
3. **Message Schedule**: Expanding blocks into 64 32-bit words
4. **Compression**: 64 rounds of transformation using SHA256 constants
5. **Finalization**: Producing the 256-bit digest

### Constants Used
- **Initial Hash Values**: First 8 prime numbers square roots fractional parts
- **Round Constants**: First 64 prime numbers cube roots fractional parts

## Performance Notes

- Processes data in 512-bit blocks
- Suitable for large files through stream processing
- Pure C++ implementation without external dependencies

## Common Use Cases

### File Integrity Verification
```cpp
bool verify_file_integrity(const std::string& filename, const std::string& expected_hash) {
    std::ifstream file(filename, std::ios::binary);
    std::bytearray content;
    content.readAllFromStream(file);
    
    std::string actual_hash = sha256::getMessageDigest(content).tohex();
    return actual_hash == expected_hash;
}
```

### Password Hashing
```cpp
std::string hash_password(const std::string& password) {
    return sha256::getHexMessageDigest(password);
}
```

### Data Comparison
```cpp
bool compare_data(const std::bytearray& data1, const std::bytearray& data2) {
    return sha256::getMessageDigest(data1) == sha256::getMessageDigest(data2);
}
```